import type { AnalysisResult, FirewallRule, RuleAnalysisIssue, RulesetSummary, RuleAction, Protocol } from './types';

const DEFAULT_IPTABLES_SAVE = `# Generated by iptables-save v1.8.7
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -s 10.0.0.0/8 -j ACCEPT
-A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT
-A INPUT -p udp --dport 53 -j ACCEPT
-A INPUT -s 192.168.1.0/24 -p tcp --dport 3306 -j ACCEPT
-A INPUT -s 0.0.0.0/0 -p tcp --dport 22 -j LOG --log-prefix "SSH access from public: "
-A INPUT -s 0.0.0.0/0 -p tcp --dport 22 -j REJECT
-A INPUT -j DROP
COMMIT
`;

export function getDefaultRuleset(): string {
  return DEFAULT_IPTABLES_SAVE;
}

function getAction(target: string): RuleAction {
    const upperTarget = target.toUpperCase();
    const validActions: RuleAction[] = ['ACCEPT', 'DROP', 'REJECT', 'LOG', 'REDIRECT', 'MASQUERADE', 'DNAT', 'SNAT'];
    if (validActions.includes(upperTarget as RuleAction)) {
        return upperTarget as RuleAction;
    }
    return 'UNKNOWN';
}

function getProtocol(proto: string): Protocol {
    const lowerProto = proto.toLowerCase();
    const validProtocols: Protocol[] = ['tcp', 'udp', 'icmp', 'all'];
    if (validProtocols.includes(lowerProto as Protocol)) {
        return lowerProto as Protocol;
    }
    return 'unknown';
}

function getRuleDescription(rule: Omit<FirewallRule, 'id' | 'riskScore' | 'description'>): string {
    const action = rule.target.toLowerCase();
    const protocol = rule.protocol === 'all' ? '' : ` ${rule.protocol}`;
    const source = rule.source === '0.0.0.0/0' || rule.source === 'anywhere' ? 'any source' : `source ${rule.source}`;
    const destination = rule.destination === '0.0.0.0/0' || rule.destination === 'anywhere' ? 'any destination' : `destination ${rule.destination}`;

    return `This rule will ${action} ${protocol} traffic from ${source} to ${destination} in the ${rule.chain} chain.`;
}

export function parseAndAnalyze(text: string): AnalysisResult {
    const lines = text.split('\n');
    const rules: FirewallRule[] = [];
    const analysis: RuleAnalysisIssue[] = [];

    const parsedLines = lines.map((line, index) => ({ line: line.trim(), index: index + 1 }))
        .filter(item => item.line.startsWith('-A'));
    
    let lineNum = 0;
    parsedLines.forEach(({ line: trimmedLine, index: originalLineNum }) => {
        lineNum++;
        const id = `rule-${originalLineNum}`;
        const raw = trimmedLine;

        const chainMatch = trimmedLine.match(/-A\s+(\S+)/);
        const chain = chainMatch ? chainMatch[1] : 'UNKNOWN';

        const protocolMatch = trimmedLine.match(/-p\s+(\S+)/);
        const protocol = getProtocol(protocolMatch ? protocolMatch[1] : 'all');

        const sourceMatch = trimmedLine.match(/-s\s+(\S+)/);
        const source = sourceMatch ? sourceMatch[1] : '0.0.0.0/0';

        const destMatch = trimmedLine.match(/-d\s+(\S+)/);
        const destination = destMatch ? destMatch[1] : '0.0.0.0/0';

        const targetMatch = trimmedLine.match(/-j\s+(\S+)/);
        const target = getAction(targetMatch ? targetMatch[1] : 'UNKNOWN');

        let riskScore = 1;
        if (target === 'ACCEPT' && source === '0.0.0.0/0') riskScore = 8;
        if (target === 'ACCEPT') riskScore += 2;
        if (target === 'DROP' || target === 'REJECT') riskScore = 1;
        if (protocol === 'tcp' && (trimmedLine.includes('--dport 22') || trimmedLine.includes('--dport 3389'))) riskScore += 2;
        riskScore = Math.min(10, Math.max(1, riskScore));
        
        const description = getRuleDescription({ chain, protocol, source, destination, target, raw });

        const rule: FirewallRule = { id, raw, chain, protocol, source, destination, target, riskScore, description };
        rules.push(rule);
    });

    rules.forEach((rule, index) => {
        // Find previous rules in the same chain
        const precedingRules = rules.slice(0, index).filter(r => r.chain === rule.chain);

        if (rule.target === 'ACCEPT' && rule.source === '0.0.0.0/0') {
            analysis.push({
                id: `analysis-${rule.id}`,
                ruleId: rule.id,
                message: `Overly permissive rule allows access from any source IP address. Consider restricting the source.`,
                severity: 'high',
                ruleRaw: rule.raw,
            });
        }
        if (rule.target === 'DROP' && precedingRules.some(r => r.raw === rule.raw)) {
             analysis.push({
                id: `analysis-${rule.id}-dup`,
                ruleId: rule.id,
                message: 'This is a duplicate DROP rule, which might be redundant.',
                severity: 'low',
                ruleRaw: rule.raw,
            });
        }
        
        // Check for unreachable rule
        for (const precedingRule of precedingRules) {
            const isBroadDrop = (precedingRule.target === 'DROP' || precedingRule.target === 'REJECT');
            const coversSource = precedingRule.source === '0.0.0.0/0' || precedingRule.source === rule.source;
            const coversDest = precedingRule.destination === '0.0.0.0/0' || precedingRule.destination === rule.destination;
            const coversProto = precedingRule.protocol === 'all' || precedingRule.protocol === rule.protocol;

            if (isBroadDrop && coversSource && coversDest && coversProto) {
                 analysis.push({
                    id: `analysis-${rule.id}-unreach`,
                    ruleId: rule.id,
                    message: `This rule may be unreachable as it comes after a broad '${precedingRule.target}' rule in the same chain.`,
                    severity: 'medium',
                    ruleRaw: rule.raw,
                });
                break; // One unreachable finding is enough
            }
        }
    });

    const actionCounts: { [key in RuleAction]?: number } = {};
    const protocolCounts: { [key in Protocol]?: number } = {};
    let totalRisk = 0;

    rules.forEach(rule => {
        actionCounts[rule.target] = (actionCounts[rule.target] || 0) + 1;
        protocolCounts[rule.protocol] = (protocolCounts[rule.protocol] || 0) + 1;
        totalRisk += rule.riskScore;
    });

    const summary: RulesetSummary = {
        totalRules: rules.length,
        ruleCountByAction: Object.entries(actionCounts).map(([name, value]) => ({ name, value: value ?? 0 })),
        ruleCountByProtocol: Object.entries(protocolCounts).map(([name, value]) => ({ name, value: value ?? 0 })),
        averageRiskScore: rules.length > 0 ? parseFloat((totalRisk / rules.length).toFixed(1)) : 0,
        highRiskRulesCount: rules.filter(r => r.riskScore > 7).length,
        mediumRiskRulesCount: rules.filter(r => r.riskScore > 4 && r.riskScore <= 7).length,
    };

    return { rules, summary, analysis: [...new Map(analysis.map(item => [item.id, item])).values()] };
}
