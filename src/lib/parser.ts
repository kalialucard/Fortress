import type { AnalysisResult, FirewallRule, RuleAnalysisIssue, RulesetSummary, RuleAction, Protocol } from './types';

const DEFAULT_IPTABLES_SAVE = `# Generated by iptables-save v1.8.7
*filter
:INPUT ACCEPT [0:0]
:FORWARD DROP [0:0]
:OUTPUT ACCEPT [0:0]
-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -p tcp -m tcp --dport 22 -s 10.0.0.0/8 -j ACCEPT
-A INPUT -p tcp -m multiport --dports 80,443 -j ACCEPT
-A INPUT -p udp --dport 53 -j ACCEPT
-A INPUT -s 192.168.1.0/24 -p tcp --dport 3306 -j ACCEPT
-A INPUT -s 0.0.0.0/0 -p tcp --dport 22 -j LOG --log-prefix "SSH access from public: "
-A INPUT -s 0.0.0.0/0 -p tcp --dport 22 -j REJECT
-A INPUT -j DROP
COMMIT
`;

export function getDefaultRuleset(): string {
  return DEFAULT_IPTABLES_SAVE;
}

function getAction(target: string): RuleAction {
    const upperTarget = target.toUpperCase();
    const validActions: RuleAction[] = ['ACCEPT', 'DROP', 'REJECT', 'LOG', 'REDIRECT', 'MASQUERADE', 'DNAT', 'SNAT'];
    if (validActions.includes(upperTarget as RuleAction)) {
        return upperTarget as RuleAction;
    }
    return 'UNKNOWN';
}

function getProtocol(proto: string): Protocol {
    const lowerProto = proto.toLowerCase();
    const validProtocols: Protocol[] = ['tcp', 'udp', 'icmp', 'all'];
    if (validProtocols.includes(lowerProto as Protocol)) {
        return lowerProto as Protocol;
    }
    return 'unknown';
}

function getRuleDescription(rule: Omit<FirewallRule, 'id' | 'riskScore' | 'description'>): string {
    const action = rule.target.toLowerCase();
    const protocol = rule.protocol === 'all' ? '' : ` ${rule.protocol}`;
    const source = rule.source === '0.0.0.0/0' || rule.source === 'anywhere' ? 'any source' : `source ${rule.source}`;
    const destination = rule.destination === '0.0.0.0/0' || rule.destination === 'anywhere' ? 'any destination' : `destination ${rule.destination}`;

    return `This rule will ${action} ${protocol} traffic from ${source} to ${destination} in the ${rule.chain} chain.`;
}

export function parseAndAnalyze(text: string): AnalysisResult {
    const rules: FirewallRule[] = [];
    const analysis: RuleAnalysisIssue[] = [];
    let lineNum = 0;

    text.split('\n').forEach(line => {
        lineNum++;
        const trimmedLine = line.trim();
        if (!trimmedLine.startsWith('-A')) return;

        const id = `rule-${lineNum}`;
        const raw = trimmedLine;

        const chainMatch = trimmedLine.match(/-A\s+(\S+)/);
        const chain = chainMatch ? chainMatch[1] : 'UNKNOWN';

        const protocolMatch = trimmedLine.match(/-p\s+(\S+)/);
        const protocol = getProtocol(protocolMatch ? protocolMatch[1] : 'all');

        const sourceMatch = trimmedLine.match(/-s\s+(\S+)/);
        const source = sourceMatch ? sourceMatch[1] : '0.0.0.0/0';

        const destMatch = trimmedLine.match(/-d\s+(\S+)/);
        const destination = destMatch ? destMatch[1] : '0.0.0.0/0';

        const targetMatch = trimmedLine.match(/-j\s+(\S+)/);
        const target = getAction(targetMatch ? targetMatch[1] : 'UNKNOWN');

        let riskScore = 1;
        if (target === 'ACCEPT' && source === '0.0.0.0/0') riskScore = 8;
        if (target === 'ACCEPT') riskScore += 2;
        if (target === 'DROP' || target === 'REJECT') riskScore = 1;
        if (protocol === 'tcp' && (trimmedLine.includes('--dport 22') || trimmedLine.includes('--dport 3389'))) riskScore += 2;
        riskScore = Math.min(10, Math.max(1, riskScore));
        
        const description = getRuleDescription({ chain, protocol, source, destination, target, raw });

        const rule: FirewallRule = { id, raw, chain, protocol, source, destination, target, riskScore, description };
        rules.push(rule);

        if (target === 'ACCEPT' && source === '0.0.0.0/0') {
            analysis.push({
                id: `analysis-${id}`,
                ruleId: id,
                message: `Overly permissive rule allows access from any source IP address. Consider restricting the source.`,
                severity: 'high',
                ruleRaw: raw,
            });
        }
        if (target === 'DROP' && rules.some(r => r.id !== id && r.raw === raw)) {
            analysis.push({
                id: `analysis-${id}-dup`,
                ruleId: id,
                message: 'This is a duplicate DROP rule, which might be redundant.',
                severity: 'low',
                ruleRaw: raw,
            });
        }
        if (rules.findIndex(r => r.id === id) > 5 && target !== "DROP" && target !== "REJECT") {
             const lastRule = rules[rules.length-2];
             if(lastRule && (lastRule.target === 'DROP' || lastRule.target === "REJECT") && lastRule.source === '0.0.0.0/0' && lastRule.destination === '0.0.0.0/0') {
                 analysis.push({
                    id: `analysis-${id}-unreach`,
                    ruleId: id,
                    message: `This rule may be unreachable as it comes after a broad 'DROP' or 'REJECT' rule.`,
                    severity: 'medium',
                    ruleRaw: raw,
                });
             }
        }
    });

    const actionCounts: { [key in RuleAction]?: number } = {};
    const protocolCounts: { [key in Protocol]?: number } = {};
    let totalRisk = 0;

    rules.forEach(rule => {
        actionCounts[rule.target] = (actionCounts[rule.target] || 0) + 1;
        protocolCounts[rule.protocol] = (protocolCounts[rule.protocol] || 0) + 1;
        totalRisk += rule.riskScore;
    });

    const summary: RulesetSummary = {
        totalRules: rules.length,
        ruleCountByAction: Object.entries(actionCounts).map(([name, value]) => ({ name, value })),
        ruleCountByProtocol: Object.entries(protocolCounts).map(([name, value]) => ({ name, value })),
        averageRiskScore: rules.length > 0 ? parseFloat((totalRisk / rules.length).toFixed(1)) : 0,
        highRiskRulesCount: rules.filter(r => r.riskScore > 7).length,
        mediumRiskRulesCount: rules.filter(r => r.riskScore > 4 && r.riskScore <= 7).length,
    };

    return { rules, summary, analysis };
}
